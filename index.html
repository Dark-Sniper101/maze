<!DOCTYPE html>
<html>

<head>
  <title>Infinite Maze</title>
  <link rel="icon" type="image/png" href="imgs/gameIcon.png" />

  <!-- Imports Bootstrap CDN-->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.min.js"
    integrity="sha384-BBtl+eGJRgqQAUMxJ7pMwbEyER4l1g+O15P+16Ep7Q9Q+zqX6gSbd85u4mG4QzX+"
    crossorigin="anonymous"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"
    integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN" crossorigin="anonymous">

  <!-- Imports jQuery CDN -->
  <script src="https://code.jquery.com/jquery-3.7.1.js" integrity="sha256-eKhayi8LEQwp4NKxN+CfCh+3qOVUtJn3QNZ0TciWLP4="
    crossorigin="anonymous"></script>

  <!-- CSS -->
  <link rel="stylesheet" href="style.css">

  <style>
    body {
      background-color: black;
    }

    p {
      text-align: center;
      width: 600px;
      margin: auto;
    }

    form {
      text-align: center;
      color: white;
    }

    #button {
      text-align: center;
    }

    #maze {
      width: 600px;
      height: 400px;
      /* <!-- **** CSS Submission, use of margins **** --> */
      margin: auto;
      margin-top: 10px;
      /* <!-- **** CSS Submission, flexbox **** --> */
      display: flex;
      background-color: springgreen;
      flex-flow: row wrap;
      justify-content: space-around;
      align-content: space-around;

    }

    /* <!-- **** CSS Submission, using .class to get elemets **** --> */
    .mazeBack {
      width: 48px;
      height: 48px;
      background-color: grey;
    }

    .mazePlayer {
      width: 48px;
      height: 48px;
      background-color: blue;
      background-image: url("imgs/player.png");
      background-position: center;
      background-repeat: no-repeat;
      background-size: cover;
    }

    .mazeWall {
      width: 48px;
      height: 48px;
      background-color: darkslategrey;
    }

    .mazeEnd {
      width: 48px;
      height: 48px;
      background-color: yellow;
      background-image: url("imgs/trophy.png");
      background-position: center;
      background-repeat: no-repeat;
      background-size: cover;
    }

    .mazeRobot {
      width: 48px;
      height: 48px;
      background-color: red;
      background-image: url("imgs/robot.png");
      background-position: center;
      background-repeat: no-repeat;
      background-size: cover;
    }

    #mobileControls {
      display: none;
    }

    /* <!-- **** CSS Submission, media querys **** --> */
    @media (max-width: 1000px) {
      #mobileControls {
        display: block;
        width: 200px;
        height: 150px;
        margin: auto;
      }
    }
  </style>
</head>

<body>
  <!-- **** Bootstrap Submission, bootstrap coloring **** -->
  <h3 class="text-primary" align="center"><b>Score: <span id="score">0</span></b></h3>

  <!-- **** Bootstrap Submission, bootstrap buttons **** -->
  <!-- **** HTML Submission, using onclick for button to access JS function **** -->
  <div id="button"><button class="btn btn-outline-success btn-lg" onclick="generate()">Generate</button></div>
  <div id="maze"></div>

  <!-- **** HTML Submission, forms **** -->
  <form>
    <input type="radio" id="red" name="background_color" value="red">
    <label for="orangered">Red</label>

    <input type="radio" id="orange" name="background_color" value="orange">
    <label for="orange">Orange</label>

    <input type="radio" id="yellow" name="background_color" value="yellow">
    <label for="yellow">Yellow</label>

    <input type="radio" id="green" name="background_color" value="springgreen">
    <label for="green">Green</label>

    <input type="radio" id="blue" name="background_color" value="lightskyblue">
    <label for="blue">Blue</label>

    <input type="radio" id="purple" name="background_color" value="magenta">
    <label for="purple">Purple</label>
    <input type="submit">
  </form>

  <div id="mobileControls">
    <table>
      <tr>
        <td></td>
        <td><button class="btn btn-outline-success btn-lg" onclick="playerMove('w')" id="w">⬆️</button></td>
        <td></td>
      </tr>
      <tr>
        <td> <button class="btn btn-outline-success btn-lg" onclick="playerMove('a')" id="a">⬅️</button></td>
        <td></td>
        <td><button class="btn btn-outline-success btn-lg" onclick="playerMove('d')" id="d">➡️</button></td>
      </tr>
      <tr>
        <td></td>
        <td><button class="btn btn-outline-success btn-lg" onclick="playerMove('s')" id="s">⬇️</button></td>
        <td></td>
      </tr>
    </table>
  </div>
  <!-- **** Bootstrap Submission, display class for stylized heading **** -->
  <p class="display-1 text-success">Instructions</p>
  <p class="display-4 text-success">How to Play</p>

  <!-- **** HTML Submission, inline tags to change certain text in a paragraph **** -->
  <p class="text-success"> Your player is the blue square and your objective is to make your way through this maze and
    reach the end, marked by the yellow square, once you do you'll get an increase in your score and a new maze will be
    generated, but be wary, the red killer robot is after you, if you touch it, you die, the robot won't try to touch
    you but if you touch it you will lose all your score and be sent to a new map. Important: <b class="text-danger">On
      exit or refresh of this site your score will reset!</b> The controls are the WASD keys for moving up down left and
    right, it also important to know that the robot will move whenever you do. Also, if you want a new maze, press the
    "Generate" button that's just above the maze to generate a new maze. </p>
  <p class="display-4 text-success">Background</p>

  <!-- **** HTML Submission, anchors that lead to different sites **** -->
  <p class="text-success"> This project is based on one of my previous projects, <a class="text-info"
      href="https://sprig.hackclub.com/gallery/hidden_maze_infinite">Hidden Maze Infite</a>, which I made for Hack
    Club's Sprig Gallery, which you can learn more about, <a class="text-info"
      href="https://sprig.hackclub.com/">here</a>.</p>
  <p class="text-secondary">Make sure caps lock is off, otherwise the controls will not work.</p>
  <!-- JS -->
  <script>
    let score = 0;
    const botSpawnRate = 5;
    const maxBots = 10;
    let buttonClicks = 0;
    let player = {
      x: 0,
      y: 0,
    };

    let robots = [];
    //htmlGrid gives acess to the html, gameGrid is where the maze will be generated then tranfered to html afterwards
    let htmlGrid = [];
    let gameGrid = [];
    let height = 8;
    let width = 12;



    //changing background color of maze
    /* <!-- **** jQuery substitute for Bootstrap Feature Submission (if needed), getting elements and provided methods **** -->*/
    $("form").submit(function (e) {
      e.preventDefault();
      let color = $("input[name='background_color']:checked").val();
      $("#maze").css("background-color", color);
    })
    /* <!-- **** jQuery substitute for Bootstrap Feature submission, document ready function **** --> */
    $(document).ready(function () {
      /* <!-- **** JavaScript Submission, getElementById function **** --> */
      let maze = document.getElementById("maze");
      for (let i = 0; i < height; i++) {
        htmlGrid[i] = [];
        gameGrid[i] = [];
        for (let j = 0; j < width; j++) {
          var baseCell = document.createElement("div");
          baseCell.classList.add("mazeBack");
          var thisCell = maze.appendChild(baseCell);
          /* <!-- **** JavaScript Submission, 2d arrays **** --> */
          htmlGrid[i][j] = thisCell;
          gameGrid[i][j] = ".";
        }
      }
      gameGrid = mazeGenerator();

      updateBot();

      transferToHTML();
    })

    //This function converts the gameGrid to the html page
    function transferToHTML() {
      for (let i = 0; i < gameGrid.length; i++) {
        for (let j = 0; j < gameGrid[i].length; j++) {
          htmlGrid[i][j].className = '';
          switch (gameGrid[i][j]) {
            case ".":
              /* <!-- **** JS Submission, .className to set the class of elements **** --> */
              htmlGrid[i][j].className = "mazeBack";
              break;
            case "p":
              htmlGrid[i][j].className = "mazePlayer";
              break;
            case "w":
              htmlGrid[i][j].className = "mazeWall";
              break;
            case "e":
              htmlGrid[i][j].className = "mazeEnd";
              break;
            case "r":
              htmlGrid[i][j].className = "mazeRobot";
              break;
          }
        }
      }
    }
    /* <!-- **** JS Submission, addEventListener function **** --> */
    document.addEventListener("keypress", function (e) {
      e.preventDefault();
      playerMove(e.key);
    })

    function playerMove(moveKey) {
      let oldPlayerX = player.x;
      let oldPlayerY = player.y;
      switch (moveKey) {
        case "w":
          if (player.y - 1 >= 0 && gameGrid[player.y - 1][player.x] != "w") {
            if (gameGrid[player.y - 1][player.x] == "e") {
              gameGrid = mazeGenerator();
              player.x = 0;
              player.y = 0;
              updateScore();
              updateBot();
              transferToHTML();
            } else {
              //gameGrid[player.y][player.x] =".";
              //gameGrid[--player.y][player.x] ="p";
              updateScreen(player.x, player.y, player.x, --player.y);
            }
          }
          break;
        case "a":
          if (player.x - 1 >= 0 && gameGrid[player.y][player.x - 1] != "w") {

            if (gameGrid[player.y][player.x - 1] == "e") {
              gameGrid = mazeGenerator();
              player.x = 0;
              player.y = 0;
              updateScore();
              updateBot();
              transferToHTML();
            } else {
              //gameGrid[player.y][player.x] =".";
              //gameGrid[player.y][--player.x] = "p";
              updateScreen(player.x, player.y, --player.x, player.y);
            }
          }
          break;
        case "s":
          if (player.y + 1 < height && gameGrid[player.y + 1][player.x] != "w") {
            if (gameGrid[player.y + 1][player.x] == "e") {
              gameGrid = mazeGenerator();
              player.x = 0;
              player.y = 0;
              updateScore();
              updateBot();
              transferToHTML();
            } else {
              //gameGrid[player.y][player.x] =".";
              //gameGrid[++player.y][player.x] ="p";
              updateScreen(player.x, player.y, player.x, ++player.y);
            }
          }
          break;
        case "d":
          if (player.x + 1 < width && gameGrid[player.y][player.x + 1] != "w") {
            if (gameGrid[player.y][player.x + 1] == "e") {
              gameGrid = mazeGenerator();
              player.x = 0;
              player.y = 0;
              updateScore();
              updateBot();
              transferToHTML();
            } else {
              //gameGrid[player.y][player.x] =".";
              //gameGrid[player.y][++player.x] ="p";
              updateScreen(player.x, player.y, ++player.x, player.y);
            }
          }
          break;
        default:
          break;
      }
      for (const robot of robots) {
        if (robot.x == player.x && robot.y == player.y) {
          gameGrid = mazeGenerator();
          player.x = 0;
          player.y = 0;
          //I set score to -1 because update score adds 1 to the current score and changes what the page displays for the score, so instead of making a whole new method I just make it -1 so when updateScore is ran the score is made 0.
          score = -1;
          updateScore();
          robots = [];
          robots[0] = new Bot();
          transferToHTML();
          break;
        } else {
          robot.move();
        }
      }
      //transferToHTML();
    }

    function updateScreen(oX, oY, nX, nY) {
      let item = gameGrid[oY][oX];
      gameGrid[oY][oX] = ".";
      gameGrid[nY][nX] = item;

      htmlGrid[oY][oX].className = "";
      htmlGrid[oY][oX].className = "mazeBack";
      htmlGrid[nY][nX].className = "";
      switch (item) {
        case "p":
          htmlGrid[nY][nX].className = "mazePlayer";
          break;
        case "r":
          htmlGrid[nY][nX].className = "mazeRobot";
          break;
        default:
          console.log('Error item "' + item + '" not recognized');
          break;
      }
    }

    function updateBot() {
      for (let i = 0; i < maxBots &&
        score >= i * botSpawnRate; i++) {
        robots[i] = new Bot();
      }

      /*this change was made so I can easily test the bot spawn and this also makes it so the bots spawn based on the score itself instead of spawning one for every 5 score
      if (score != 0 && score%5 == 0 && robots.length <= 5){
        robots[robots.length] = null;
      }
      for(let i = 0; i < robots.length; i++){
        robots[i] = new Bot();
      }*/
    }

    function generate() {
      gameGrid = mazeGenerator();
      player.x = 0;
      player.y = 0;
      buttonClicks++;
      for (let i = 0; i < robots.length; i++) {
        robots[i] = new Bot();
      }
      transferToHTML();
      if (buttonClicks % 100 == 0) {
        window.alert(`You have clicked the generate maze button ${buttonClicks} times! \n Why?`)
      }
    }

    function updateScore() {
      document.getElementById("score").textContent = ++score;
    }


    //KILLER ROBOTS!!!
    class Bot {
      constructor() {
        let xx = Math.floor(Math.random() * width);
        let yy = Math.floor(Math.random() * height);
        while (gameGrid[yy][xx] != ".") {
          xx = Math.floor(Math.random() * width);
          yy = Math.floor(Math.random() * height);
        }
        gameGrid[yy][xx] = "r";

        this.x = xx;
        this.y = yy;
      }
      up = function () {
        let newY = (((this.y - 1) % height) + height) % height;
        updateScreen(this.x, this.y, this.x, newY);
        //gameGrid[this.y][this.x] =".";
        this.y = newY;
        //gameGrid[this.y][this.x] ="r";
      }

      down = function () {
        let newY = (this.y + 1) % height;
        updateScreen(this.x, this.y, this.x, newY);
        //gameGrid[this.y][this.x] =".";
        this.y = newY;
        //gameGrid[this.y][this.x] ="r";
      }

      left = function () {
        let newX = (((this.x - 1) % width) + width) % width;
        updateScreen(this.x, this.y, newX, this.y);
        //gameGrid[this.y][this.x] =".";
        this.x = newX;
        //gameGrid[this.y][this.x] ="r";
      }

      right = function () {
        let newX = (this.x + 1) % width;
        updateScreen(this.x, this.y, newX, this.y);
        //gameGrid[this.y][this.x] =".";
        this.x = newX;
        //gameGrid[this.y][this.x] ="r";
      }

      move = function () {
        let moveSpots = []
        let count = 0;
        /*(this.y-1>=0&&*/
        // I'm using this: ((((this.y-1)%height)+height)%height); because as I've recently learned, when in the equation a % b, if a is negative then the output is negative, which is different from what the google calculator does, so this is a workaround
        if (gameGrid[(((this.y - 1) % height) + height) % height][this.x] == ".") {
          moveSpots[count++] = "up";
        }
        /*this.y+1<height &&*/
        if (gameGrid[(this.y + 1) % height][this.x] == ".") {
          moveSpots[count++] = "down";
        }
        /*this.x-1>=0&&*/
        if (gameGrid[this.y][(((this.x - 1) % width) + width) % width] == ".") {
          moveSpots[count++] = "left";
        }
        /*this.x+1<width &&*/
        if (gameGrid[this.y][(this.x + 1) % width] == ".") {
          moveSpots[count++] = "right";
        }

        if (count > 0) {
          let move = moveSpots[Math.floor(Math.random() * count)];
          switch (move) {
            case "up":
              this.up();
              break;
            case "down":
              this.down();
              break;
            case "left":
              this.left();
              break;
            case "right":
              this.right();
              break;
          }
        }
      }

    }

    function mazeGenerator() {
      let maze = [];
      let visitMap = [];
      for (let i = 0; i < height; i++) {
        maze[i] = [];
        visitMap[i] = []
        for (let j = 0; j < width; j++) {
          maze[i][j] = "w";
          visitMap[i][j] = false;
        }
      }
      /* This is where I start using code from one of my older projects, you can see it with this link: 
      https://sprig.hackclub.com/share/UjxG0OZ8eifhewYYg9Ua
      It's also important to note that all the comments made in the following code were from that project and I don't feel like removing them. */
      class XYPos {
        constructor(xx, yy) {
          this.x = xx;
          this.y = yy;
        }
      }

      //makes a radomized maze
      let prePos = new XYPos(-1, -1);
      let nextPos = new XYPos(0, 0);
      //makes main path
      while (!(nextPos == null || nextPos == undefined)) {
        let temp = nextPos;
        nextPos = moveNext(nextPos.x, nextPos.y, prePos.x, prePos.y);
        prePos = temp;
      }
      maze[prePos.x][prePos.y] = "e";
      visitMap[prePos.x][prePos.y] = true;

      //makes other pathsc
      for (let a = 0; a < maze.length; a++) {
        for (let b = 0; b < maze[a].length; b++) {
          nextPos = new XYPos(a, b);
          prePos = new XYPos(a, b);
          if (maze[a][b] != "w") {

            //changes adjasent path squares to not visited
            for (let i = -1; i <= 1; i++) {
              for (let j = -1; j <= 1; j++) {
                if (a + i >= 0 && a + i < maze.length && //checks if a+i is in the array
                  b + j >= 0 && b + j < maze[0].length && //checks if b+j is in the array
                  (i == 0 || j == 0) &&//this should see if the area's to move to are next(up,down,left,or right) to [a][b]
                  maze[a + i][b + j] != "w") { //checks if is wall
                  visitMap[a + i][b + j] = false;
                }
              }
            }
            nextPos = new XYPos(a, b)
            let temp = nextPos;
            nextPos = moveNext(nextPos.x, nextPos.y, prePos.x, prePos.y);
            prePos = temp;
            visitMap[prePos.x][prePos.y] = true;

            //sets changed paths back to visited
            for (let i = -1; i <= 1; i++) {
              for (let j = -1; j <= 1; j++) {
                if (a + i >= 0 && a + i < maze.length && //checks if a+i is in the array
                  b + j >= 0 && b + j < maze[0].length && //checks if b+j is in the array
                  maze[a + i][b + j] != "w") { //checks if is wall
                  visitMap[a + i][b + j] = true;
                }
              }
            }

            while (!(nextPos == null || nextPos == undefined)) {
              temp = nextPos;
              nextPos = moveNext(nextPos.x, nextPos.y, prePos.x, prePos.y);
              prePos = temp;
            }
            visitMap[prePos.x][prePos.y] = true;
          }
        }
      }
      maze[0][0] = "p";
      return maze;

      //Determines the next position to move to
      function moveNext(x, y, k, t) {//x & y are current position, k & t are previous position
        let arr = new Array;
        let count = 0;
        for (let i = -1; i <= 1; i++) {
          for (let j = -1; j <= 1; j++) {
            if (x + i >= 0 && x + i < maze.length && //checks if x+i is in the array
              y + j >= 0 && y + j < maze[0].length && //checks if y+j is in the array
              (i == 0 || j == 0) && i != j && //this should see if the area's to move to are next(up,down,left,or right) to [x][y] but not [x][y]
              nextToVisited(x + i, y + j) && //checks if [x+i][y+j] is next to a visited Cell
              !(maze[x + i][y + j] == null || maze[x + i][y + j] == undefined) && //checks if [x+i][y+j] containes nothing
              visitMap[x + i][y + j] == false && //checks if is a visited cell
              !(x + i == k && y + j == t)) { //check if [x+i][y+j] equals [k][t]
              arr[count++] = new XYPos(x + i, y + j); //XYPos is a simple object that cotains an x and y cordinate so I can return one thing
            }
          }
        }
        if (k >= 0 && t >= 0) {
          visitMap[k][t] = true;
        }
        if (maze[x][y] != "e")
          maze[x][y] = ".";
        return arr[Math.floor(Math.random() * arr.length)]
      }

      function nextToVisited(x, y) {
        for (var i = -1; i <= 1; i++) {
          for (var j = -1; j <= 1; j++) {
            if (x + i >= 0 && x + i < maze.length &&
              y + j >= 0 && y + j < maze[0].length &&
              !(i == 0 && j == 0) &&
              !(maze[x + i][y + j] == null || maze[x + i][y + j] == undefined) &&
              (visitMap[x + i][y + j]) == true) {
              return false;
            }
          }
        }
        return true;
      }
    }

  </script>
</body>

</html>